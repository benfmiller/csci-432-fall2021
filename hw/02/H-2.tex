\documentclass{article}
\usepackage{../fasy-hw}

%% UPDATE these variables:
\renewcommand{\hwnum}{1}
\title{Advanced Algorithms, Homework \hwnum}
\author{Ben Miller}
\collab{\todo{list your collaborators here}}
\date{due: 29 September 2021}

\begin{document}

\maketitle

This homework assignment should be
submitted as a single PDF file both to D2L and to Gradescope.

General homework expectations:
\begin{itemize}
    \item Homework should be typeset using LaTex.
    \item Answers should be in complete sentences and proofread.
    \item You will not plagiarize, nor will you share your written solutions
        with classmates.
    \item List collaborators at the start of each question using the
        \texttt{collab} command.
    \item Put your answers where the \texttt{todo} command currently is (and
        remove the \texttt{todo}, but not the word \texttt{Answer}).
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\collab{}
\nextprob{Chapter 2, Problem 4, (a)}

For each of the recursive definitions, give the recurrence
relation and state the recursion invariant.  For Part (a), prove that your
recursion invariant holds.  For Part (b), prove that your recursion terminates
using a decrementing function.


{\bf  (a)} Let $A[1.. m]$ and $B[1.. n]$ be two arbitrary arrays. A common subsequence
of A and B is both a subsequence of A and a subsequence of B. Give
a simple recursive definition for the function $lcs(A, B)$, which gives the
length of the longest common subsequence of A and B.

\paragraph{Answer}

\todo{}

\nextprob{Chapter 2, Problem 4, (b)}

For each of the recursive definitions, give the recurrence
relation and state the recursion invariant.

For Part (b), prove that your recursion terminates
using a decrementing function.

{\bf (b)} Let $A[1.. m]$ and $B[1.. n]$ be two arbitrary arrays. A common super-
sequence of A and B is another sequence that contains both A and B
as subsequences. Give a simple recursive definition for the function
$scs(A, B)$, which gives the length of the shortest common supersequence
of A and B.

\paragraph{Answer}

\todo{}

\nextprob{Chapter 2, Problem 4, (c)}

For each of the recursive definitions, give the recurrence
relation and state the recursion invariant.

{\bf (c)} Call a sequence $X[1.. n]$ of numbers bitonic if there is an index i with
1 < i < n, such that the prefix $X[1.. i]$ is increasing and the suffix
$X[i .. n]$ is decreasing. Give a simple recursive definition for the function
$lbs(A)$, which gives the length of the longest bitonic subsequence of an
arbitrary array A of integers.

\paragraph{Answer}

\todo{}

\nextprob{Chapter 2, Problem 4, (d)}

For each of the recursive definitions, give the recurrence
relation and state the recursion invariant.

{\bf (d)} Call a sequence $X[1.. n]$ oscillating if $X[i] < X[i + 1]$ for all even i, and
$X[i] > X[i + 1]$ for all odd i. Give a simple recursive definition for
the function $los(A)$, which gives the length of the longest oscillating
subsequence of an arbitrary array A of integers.

\paragraph{Answer}

We will calculate this like we did the first way for longest increasing subsequence, but we'll add a
flag to tell if it's increasing or decreasing (even or odd)
The initial call to the recursive algorithm gives even as false to account for the sentinel value

\begin{algorithm} \caption{\textsc{LongestOscillating} ($A[1..n]$)}\label{alg:seb}
    {\bf Input:} A sequence\\
    {\bf Output:} The length o the longest oscillating subsequence
    \begin{algorithmic}[1]
        \State$A[0] \gets - \infty$
        \State$return\ LongestOscillatingRecursive(0, 1, false) -1$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm} \caption{\textsc{LongestOscillatingRecursive} (i, j, even)}\label{alg:seb}
    {\bf Input:} indexes i and j, and boolean if even\\
    {\bf Output:} length of Longest Oscillating Subsequence
    \begin{algorithmic}[1]
        \If{$j > n$}
            \State$return\ 0$
        \ElsIf{$even = true$}
            \If{$A[i] \geq A[j]$}
                \State$return\ LongestOscillatingRecursive(i, j+1, even)$
            \EndIf{}
        \ElsIf{$even = false$}
            \If{$A[i] \leq A[j]$}
                \State$return\ LongestOscillatingRecursive(i, j+1, even)$
            \EndIf{}
        \Else{}

        \State$skip \gets LongestOscillatingRecursive(i, j+1, even)$
        \State$take \gets LongestOscillatingRecursive(i, j+1, not even) +1$

        \State$return\ max\{skip, take\}$
        \EndIf{}
    \end{algorithmic}
\end{algorithm}

\footnote{With help from the textbook}

% if j > n
% return 0
% else if A[i] ≥ A[j]
% return LISbigger(i, j + 1)
% else
% skip ← LISbigger(i, j + 1)
% take← LISbigger(j, j + 1) + 1
% return max{skip,take}




\todo{}

\nextprob{Chapter 2, Problem 4, (e)}

For each of the recursive definitions, give the recurrence
relation and state the recursion invariant.

{\bf (e)} Give a simple recursive definition for the function $sos(A)$, which gives
the length of the shortest oscillating supersequence of an arbitrary array
A of integers.

\paragraph{Answer}

\todo{}

\nextprob{Chapter 2, Problem 4, (f)}

For each of the recursive definitions, give the recurrence
relation and state the recursion invariant.

{\bf (f)} Call a sequence $X[1.. n]$ convex if $2 \cdot X[i] < X[i-1] + X[i+1]$ for all i.
Give a simple recursive definition for the function $lxs(A)$, which gives
the length of the longest convex subsequence of an arbitrary array A of
integers

\paragraph{Answer}

For this one, we'll put $\infty$ then $-\infty$ on both sides of the array, then we'll check to see
if the next element is equal to t times the current one - the previous one. We'll just have to
remember the current element and the previous element.

\begin{algorithm} \caption{\textsc{LongestOscillating} ($A[1..n]$)}\label{alg:seb}
    {\bf Input:} A sequence\\
    {\bf Output:} The length o the longest oscillating subsequence
    \begin{algorithmic}[1]
        \State$A[0] \gets \infty$
        \State$A[n+1] \gets \infty$
        \State$positiveMax = LongestOscillatingRecursive(0, 0, 1) -2$
        \State$A[0] \gets -\infty$
        \State$A[n+1] \gets -\infty$
        \State$negativeMax = LongestOscillatingRecursive(0, 0, 1) -2$
        \State$return\ max\{positiveMax, negativeMax\}$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm} \caption{\textsc{LongestConvexRecursive} (i, j, k)}\label{alg:seb}
    {\bf Input:} indexes i, j, and k\\
    {\bf Output:} length of Longest Convex Subsequence
    \begin{algorithmic}[1]
        \If{$k > n$}
            \State$return\ 0$
            \ElsIf{$2 \cdot A[j] \geq A[j] + A[k]$}
            \State$return\ LongestConvexRecursive(i, j, k +1)$
        \EndIf{}
        \Else{}
            \State$skip \gets LongestConvexRecursive(i, j, k+1)$
            \State$take \gets LongestConvexRecursive(j, k, k+1) +1$
        \State$return\ max\{skip, take\}$
        \EndIf{}
    \end{algorithmic}
\end{algorithm}
\todo{}
\end{document}
