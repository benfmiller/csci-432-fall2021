\documentclass{article}
\usepackage{../fasy-hw}
\usepackage{hyperref}

%% UPDATE these variables:
\renewcommand{\hwnum}{4}
\title{Advanced Algorithms, Homework \hwnum}
\author{Ben Miller, Devan Eastman-Pittam}
\collab{\todo{list your collaborators here}}
\date{due: Monday, 25 October 2021}

\begin{document}

\maketitle

This homework assignment should be
submitted as a single PDF file both to D2L and to Gradescope.

General homework expectations:
\begin{itemize}
    \item Homework should be typeset using LaTex.
    \item Answers should be in complete sentences and proofread.
    \item You will not plagiarize, nor will you share your written solutions
        with classmates.
    \item List collaborators at the start of each question using the
        \texttt{collab} command.
    \item Put your answers where the \texttt{todo} command currently is (and
        remove the \texttt{todo}, but not the word \texttt{Answer}).
    \item If you are asked to come up with an algorithm, you are
        expected to give an algorithm that beats the brute force (and, if possible, of
        optimal time complexity). With your algorithm, please provide the following:
        \begin{itemize}
            \item \emph{What}: A prose explanation of the problem and the algorithm,
                including a description of the input/output.
            \item \emph{How}: Describe how the algorithm works, including giving
                psuedocode for it.  Be sure to reference the pseudocode
                from within the prose explanation.
            \item \emph{How Fast}: Runtime, along with justification.  (Or, in the
                extreme, a proof of termination).
            \item \emph{Why}: Statement of the loop invariant for each loop, or
                recursion invariant for each recursive function.
        \end{itemize}
\end{itemize}

{\bf
This homework can be submitted as a group of size $3$ or $4$.  This group will
be your project.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\collab{Ben, Devan}
\nextprob{Class Project}

Answer the following questions relating to your group project for this class.
The answers provided here are not binding for your course project, but are meant
to help you think about the project and start planning for it.

\begin{enumerate}

    \item For each team member, provide one strength and one weakness, as it
        pertains to the course project.  (Note: everyone has strengths and
        weaknesses.  The weaknesses that you are able to identify are those that
        you are able to work on addressing).

        \paragraph{Answer}

{\bf  Devan:}

    Strength: Analysis and Comparison

    Weakness: Proof writing

{\bf  Ben:}

    Strength: Pseudocode writing

    Weakness: Getting all elements of proofs

    \item Suppose your group goes for the research option.  Find two ``recent"
        algorithms that were published in a journal or a conference.  Describe
        the problem that these algorithms solve.

        \paragraph{Answer}

{\bf  \href{https://ieeexplore.ieee.org/abstract/document/5543008?casa_token=D1odCKAaZkgAAAAA:1etG4bLeVzd78znBB9EU5xlRCj7vBHUZOe2n-BKf63L2cwwu9jWJKBNUCLVlcELgTDa0tlIqcYk}{An analysis of TZSearch algorithm in JMVC}}

    This paper analyses under which conditions and with what thresholds TZSearch performs the best. TZSearch is a video encoding algorithm that takes motion into account.

{\bf  \href{https://link.springer.com/chapter/10.1007/978-3-642-21551-3_6}{The EM Algorithm}}

This algorithm solves Maximum likelihood estimates using an iterative approach.on incomplete data problems.

    \item Suppose your group goes for the implementation option. Describe two
        methods that you can use to compare implementations.

        \paragraph{Answer}
    1: {\bf runtime analysis ( memory analysis ) O() Theta()}

A primary aspect of concern when considering an implementation is the runtime or space efficiency. Comparing worst case performance is often the most relevant aspect of algorithms in academic settings. However, sometimes algorithms have larger overheads that make another implementation with a worse runtime actually better in most cases. An example is choosing between quicksort and mergesort. Depending on the input data, either one could perform better.

    2: {\bf Complexity of implementation/proof}

This mainly involves the amount of code and the difficulty of implementing the algorithm into your program. An example is needing to use a very rare data structure to interface with the algorithm instead of something common like an array or a tree or needing 7000 lines of code just to run the algorithm instead of a more common and easily usable 30 line algorithm. Obviously the 30 line algorithm will be chosen 99\% of the time unless you have a highly niche purpose that necessitates choosing a rare data structure or algorithm, it's not worth using unless you have a very niche specialized purpose.

\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\collab{Ben}
\nextprob{Different Sources}

For this problem, choose either the Edit distance algorithm (Section 3.7).
Find three additional sources (including the textbook) that describe
and analyze the same algorithm. In one to two pages, describe the similarities
and differences in the presentation and analysis of the algorithms. (Note:
proper citations are expected).

1. Textbook

2. \href{https://medium.com/@ethannam/understanding-the-levenshtein-distance-equation-for-beginners-c4285a5604f0}{medium.com}

3. \href{https://people.cs.pitt.edu/~kirk/cs1501/Pruhs/Spring2006/assignments/editdistance/Levenshtein%20Distance.htm}{people.cs.pitt.edu}

\paragraph{Answer}

All three of these sources do a great job explaining the Levenshtein distance algorithm in different ways, I particularly liked the book's explanation of the algorithm. I prefer more detail, and the book doesn't disappoint!

The book builds from the ground up, starting with the problem description, going through the simplest recursive algorithm, then building to the dynamic programming algorithm. This book is written in a relatively linear fashion going from simple recursion all the way to the smartest recursion, so the layout of this presentation serves to illustrate the book's algorithmic development principles.

The medium.com article is written for the very beginner. One thing I especially appreciated about this article is how direct it was about its contents. The explanation of the author's direction in learning the algorithm is clearly followed through in the algorithm's explanation. One thing I was not expecting in this article was the explanation of a piecewise function. As the warning in the introduction says, it was a little "needlessly tedious," but not overly so.

The third article is written by some people at the University of Pittsburgh. On first impression, this page looked a little dry as it does not have much styling. After I looked a little closer, I found the explanations to be nicely straight forward and the code and tables illuminating. This article is all about implementation.

In terms of illustrations, the textbook probably helps with understanding the best. None of the illustrations here are distracting and they all help the explanation. The medium.com article has too many, though they are incredibly helpful with some sifting. They do have a gap in presentation, though, as the filling in of the table is not very clear. This article combined with the textbook would be good for people who prefer to learn through pictures. The Pittsburgh page focuses on the steps to perform the algorithm, so it is relatively easier to see what is going on. It does not focus much on proof or explaining why the algorithm works. I understand algorithms best by walking through them and seeing implementation, so this explanation was particularly palatable to me.

The texbook tells the most about the history and quirks of the algorithm, which I find very interesting. It is very self contained, giving good explanations about everything, but not really leaving room for further explorations. The medium article gives some good information about the algorithms and includes lots of sources for further inquiry. This article gives the most jumping off points to follow the author's course of discovery. The Pittsburgh page does not give much information about the algorithm other than some applications and links to discussions. This page was very easy to read and kept focus on the implementation of the algorithm rather than aspects of the algorithm. I am relatively easily distracted, so this page was great for me to keep focus on the algorithm.

These sources all seemed more different than similar in their approach. Only the textbook devoted much time to addressing running time and correctness. As a textbook, those parts of the algorithm were very necessary and informative. The other two sources were focused less on comprehensiveness and more focused on implementation and general intuition. All of these sources left me with a greater understanding of the algorithm and were effective explanations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\collab{Ben}
\nextprob{Dynamic Programming}

Suppose someone poses a problem to you, and you have a hunch that it can be
solved with a dynamic program.  Describe, in your own words, the steps you will
take to work through finding a solution to the problem.  If it helps, you can
choose an example to illustrate working through the process.

\paragraph{Answer}

Generally, a better solution is discovered as more details of the problem are discovered. However, those details often become apparent quite early in the problem solving process.

If the dynamic programming solution is not discovered after the initial problem exploration, I will start solving the problem in the simplest manner possible. Optimizations are then implemented as they are discovered.

If I still have a hunch that there is a dynamic programming solution that is not discovered yet, I will start to think about the different memoization structures that could be used. The end goal of dynamic programming is to reduce recalculation, so the evaluation order also determines what memoization structure can be used.

The base cases need to be considered to set up the initial memoization state.

If a dynamic programming algorithm is determined, it needs to be analysed for correctness and runtime/space efficiency and tested.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\collab{Devan}
\nextprob{Greedy Schedule}

Chapter 4, Question 1 (Greedy Schedule).  I encourage you to think through all 9
alternative schedules.  However, you only need to hand in two:
\begin{enumerate}
    \item Choose one alternate strategy that
        works, and prove that it works.


    \paragraph{Answer}
Choose a course x that conflicts with the fewest other courses, discard all classes that conflict with x, and recurse.

Since by definition this will take the option with least conflict IE: most overall classes we know that a more optimal greedy solution does not exist. This only finds a single maximal list of courses but not all of them, thus we can have more than one equal maximal course list. If an option x exists that reduces more conflicts it would become the one with the least conflicts and would replace the current choice therefore this will always work no matter how many courses are added or removed.

    \item Choose one alternate strategy that does not work, and give a
        counter-example.

    \paragraph{Answer}
Choose the course x that starts last, discard all classes that conflict with x, and recurse.

The counterexample is that In an arbitrary schedule S if there exists a schedule in which the course x starts last. Assuming another Schedule S2 exists with all the same courses in S1 Except x which is replaced by an arbitrary course c that starts before x not violating the premise but it ends after x then the algorithm will not be maximal, since v is interchangeable with x but it is longer since both courses share the same previous courses

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\collab{Devan}
\nextprob{Real Graphs}

Describe a ``real-life'' problem that can be modeled as:

\begin{enumerate}
    \item An undirected graph.

        \paragraph{Answer}

        Describing the connections of Facebook friends, you make a connection with a person(node) and the connection goes both ways where you see both people’s posts

    \item A directed, weighted graph.

        \paragraph{Answer}
    When a trucking company decides which way to send goods to a desired location and has to balance cost and efficiency, like to take toll roads or not that might save time but be more expensive

    \item A tree.

        \paragraph{Answer}

    Describing the genealogy records of a person, shows relatives of a person with root being your ancestor and you being the leaf node last or you being the root with a upwards tree branching out into all ancestors

    \item A forest.

        \paragraph{Answer}
    Graphing the genealogical trees for each person in the same family. Each person will be a tree but will be grouped together forming a forest

\end{enumerate}

\end{document}
